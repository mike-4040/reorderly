# User Management

## Overview

The Reorderly application maintains two separate user systems that work together to provide authentication and data management.

## User Types

### 1. App User (`User`)

**Location:** `functions/src/users/types.ts`

**Purpose:** Application-level user data stored in PostgreSQL

**Table:** `users`

**Schema:**

```typescript
{
  id: string;                    // Firebase Auth UID (unique per person)
  merchantId: string;             // Reference to merchant ID
  accountSetupComplete: boolean;  // Has user set up email/password?
  providerUserId?: string;        // Optional: Square merchant ID
  role: string;                   // User role (owner, admin, manager, staff)
  emailVerifiedAt?: string;       // ISO date string
  emailVerificationSentAt?: string; // ISO date string
  passwordSetAt?: string;         // ISO date string
  createdAt: string;              // ISO date string
  updatedAt: string;              // ISO date string
}
```

**Key Characteristics:**

- Stored in PostgreSQL `users` table
- Links Firebase Auth users to merchants
- Tracks account setup status
- Supports multiple users per merchant (team members, roles)
- Queryable for application logic

**Use Cases:**

- Determine which merchant a user belongs to
- Track whether user completed account setup
- List all users with access to a merchant
- Store provider-specific user IDs (e.g., Square merchant ID)

### 2. Auth User (`UserRecord`)

**Location:** Firebase Authentication service

**Purpose:** Authentication and identity management

**Schema:**

```typescript
{
  uid: string;              // Unique Firebase Auth ID
  displayName?: string;     // User's display name
  email?: string;           // Optional email (for email/password auth)
  disabled?: boolean;       // Account status
  metadata: {
    creationTime: string;
    lastSignInTime: string;
  }
  // ... other Firebase Auth fields
}
```

**Key Characteristics:**

- Managed by Firebase Authentication
- Provides authentication tokens (custom tokens, ID tokens)
- Can exist without email (for OAuth-only users)
- Cannot be directly queried like Firestore
- Used for authentication, not business logic

**Use Cases:**

- Authenticate users (sign in/sign out)
- Generate custom tokens for web client login
- Verify ID tokens from clients
- Manage authentication state

## Relationship Between User Types

```
┌─────────────────────────┐
│  Auth User              │
│  (UserRecord)           │
│  uid: "abc123"          │  ← Unique UID per person
│  displayName: "John"    │
└───────────┬─────────────┘
            │
            │ uid = id
            ▼
┌─────────────────────────┐
│  App User               │
│  (User)                 │
│  id: "abc123"           │  ← Same as Auth UID
│  merchantId: "merch_1"  │  ← Links to merchant
│  role: "owner"          │
│  accountSetupComplete   │
└───────────┬─────────────┘
            │
            │ merchantId
            ▼
┌─────────────────────────┐
│  Merchant               │
│  id: "merch_1"          │
│  name: "Coffee Shop"    │
└─────────────────────────┘
```

**Important:** Each person gets a unique Auth UID. Multiple users can link to the same merchant via `merchantId`.

## One-to-Many Relationship

**One Merchant → Many Users**

```
Merchant: "Coffee Shop" (merch_1)
    ↓
User 1 (Owner): alice@example.com
    └─ Auth User: uid: abc123 (unique UID)
    └─ App User: users/abc123 → { merchantId: "merch_1", role: "owner" }

User 2 (Manager): bob@example.com
    └─ Auth User: uid: def456 (unique UID)
    └─ App User: users/def456 → { merchantId: "merch_1", role: "manager" }

User 3 (Staff): carol@example.com
    └─ Auth User: uid: ghi789 (unique UID)
    └─ App User: users/ghi789 → { merchantId: "merch_1", role: "staff" }
```

**Key Points:**

- Each person gets a **unique Auth User UID** (generated by Firebase)
- All users link to the **same merchant** via `merchantId` in their App User record
- The `role` field enables future role-based permissions

This allows:

- Multiple team members per merchant (each with unique Auth UID)
- Role-based access control (owner, admin, manager, staff)
- Different permission levels based on role
- Each person maintains their own authentication credentials

## When to Use Each

### Use App User (`User`) when:

- Checking which merchant a user belongs to
- Listing all users for a merchant
- Tracking account setup status
- Storing business logic data

### Use Auth User (`UserRecord`) when:

- Authenticating users
- Generating tokens
- Managing sign-in/sign-out
- Creating new auth users

## Datastore Functions

### App Users (`functions/src/datastore/users.ts`)

- `createUser(data)` - Create user in PostgreSQL
- `getUserById(id)` - Get user by Firebase Auth UID
- `updateUser(id, updates)` - Update user fields
- `getUsersByMerchantId(merchantId)` - List users for merchant
- `getUserByMerchantAndProvider(merchantId, providerUserId)` - Find user by provider
- `deleteUser(id)` - Delete user

### Auth Users (`functions/src/auth/firebase/user-manager.ts`)

- `getOrCreateAuthUser(uid, displayName)` - Get or create auth user with specific UID
- `createAuthUser(displayName)` - Create new auth user with auto-generated UID
- `generateCustomToken(uid)` - Generate token for web login

## Account Setup States

The `accountSetupComplete` field tracks whether a user has set up email/password credentials:

- `false` - User authenticated via OAuth (Square) but hasn't added email/password
- `true` - User has email/password credentials and can log in directly

This enables:

- OAuth-first onboarding (connect Square before email setup)
- Later email/password account creation
- Future: Social login integration

## Known Limitations

### Corrupted App User State

**Edge Case:** If an Auth User exists in Firebase Authentication but the corresponding App User is missing from PostgreSQL, the login flow will fail with an error.

**Symptoms:**

- User exists in Firebase Console > Authentication
- No matching record in PostgreSQL `users` table
- OAuth login flow throws `loginFlow_appUserNotFound` error

**Current Behavior:**

- Login flow explicitly detects this state and returns an error
- Error message instructs user to contact support
- No automatic recovery to prevent creating duplicate Auth Users

**Manual Recovery:**

1. Verify Auth User exists in Firebase Console
2. Create App User record manually in PostgreSQL:
   ```sql
   INSERT INTO users (id, merchant_id, provider_user_id, account_setup_complete, role)
   VALUES ('<auth-uid>', <merchant-id>, '<square-merchant-id>', false, 'owner');
   ```
3. User can retry login

**Prevention:**

- OAuth flows always create both Auth User and App User atomically
- Future: Cloud Function trigger on Auth User creation to auto-create App User
- Future: Admin API endpoint for recovery operations
